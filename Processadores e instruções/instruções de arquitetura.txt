Algoritmo arestasNaoIncidentes(G, v, eh_digrafo):

	saida = 0
	para i <- 1,..., n faça
		para j <- 1,...,n faça
			se i != v e j != v entao
				se G[i][j] == 1 então
					saida = saida + 1

	se eh_digrafo entao
		retorne saida
	senao
		retorne saida / 2

//Complexidade O(n²)

Algoritmo arestasNaoIncidentes(G, v, eh_digrafo):

	saida = 0
	para i <- 1,..., n faça
		se i != v então
			aux = G[i].prox
			enquanto aux != null faça
				se aux != v então
					saida++
				aux = aux.prox

	se eh_digrafo então
		retone saida
	senão
		retorne saida / 2

//Complexidade O(n + m)


Algoritmo grafoComplemento(G):
	
	cria uma matriz saida de adjacências;
	para i <- 1,..., n faça
		para j <- 1,..., n faça
			se i != j então
				se G[i][j] = 1 então
					saida[i][j] <- 0;
				senão
					saida[i][j] <- 1;
	retorne saida;

Algoritmo grafoComplemento(G):
	
	cria uma lista de adjacências saida;
	para i <- 1,..., n faça
		para j <- 1,..., n faça
			se i != j então
				se !contem(G[i], j) então
					saida[i].adciona(j);
	retorne saida;

Algoritmo contem(Lista, chave):
	aux <- Lista.prox;
	enquanto aux != null faça
		se aux = chave então
			retorne verdadeiro;
		aux = aux.prox;
	retorne falso;